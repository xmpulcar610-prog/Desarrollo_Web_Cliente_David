Sesi√≥n 1: Teor√≠a
üìò Material Docente: Sesi√≥n 1
Introducci√≥n a React con TypeScript: Componentes y Props
1. ¬øQu√© es React y c√≥mo funciona?

React no es un framework monol√≠tico (como Angular), es una librer√≠a enfocada en construir interfaces de usuario. Su filosof√≠a principal es romper la interfaz en piezas peque√±as, reutilizables y aisladas llamadas Componentes.
El √Årbol de Componentes

Una aplicaci√≥n React es, en esencia, un √°rbol de componentes:

    Ra√≠z: Tienes un componente principal (usualmente llamado App).
    Ramas: App contiene otros componentes (ej: Header, ProductList, Footer).
    Hojas: Los componentes m√°s peque√±os (ej: Button, Label).

Analog√≠a: Piensa en etiquetas HTML personalizadas. En lugar de escribir <div class="sidebar">...</div> repetidamente, crear√°s una etiqueta <Sidebar /> que encapsula esa l√≥gica y estilo.
2. JSX: JavaScript con sintaxis de HTML

React utiliza una extensi√≥n de sintaxis llamada JSX (JavaScript XML). Aunque parece HTML, es JavaScript. Al compilarse, se transforma en llamadas a funciones de JS que crean el DOM.
Reglas de Oro del JSX

    Todo componente debe devolver un solo elemento padre: No puedes devolver dos div hermanos sin un envoltorio. Si no quieres a√±adir nudos extra al DOM, usa un Fragmento: <> ... </>.
    Atributos camelCase: Ya no usamos class (palabra reservada en JS), usamos className. onclick se convierte en onClick.
    Cierre de etiquetas: Todas las etiquetas deben cerrarse. <br> ahora es <br />.
    Interpolaci√≥n: Para insertar valores de JavaScript en el HTML, usamos llaves { }.

Ejemplo:
const nombre = "Juan";
const elemento = <h1 className="titulo">Hola, {nombre}</h1>;
3. Creaci√≥n de Componentes Funcionales

En React moderno, los componentes son simplemente funciones que devuelven JSX.
// Definici√≥n del componente
function Welcome() {
  return <h2>Bienvenido a mi App</h2>;
}

// Uso del componente (instanciaci√≥n)
export default function App() {
  return (
    <div>
       <Welcome />
    </div>
  );
}
4. Props: Comunicaci√≥n Padre-Hijo con TypeScript

Aqu√≠ es donde TypeScript brilla. Las Props (propiedades) son los datos que un componente padre pasa a un hijo. Son de solo lectura (inmutables) para el hijo.

Sin TypeScript, no sabr√≠amos qu√© props espera un componente hasta que miramos el c√≥digo o falla. Con TypeScript, definimos un "contrato" o interfaz.
Definiendo el contrato (Interface/Type)

Usamos una interface o type para definir la forma de las props.
// 1. Definimos qu√© datos espera recibir este componente
type AlertProps = {
  text: string; // Dato obligatorio
  type: 'success' | 'error' | 'warning'; // Union type para limitar valores
  showIcon?: boolean; // Prop opcional (marcada con ?)
};

// 2. Aplicamos el tipo al componente
export const Alert = ({ text, type, showIcon = true }: AlertProps) => {
  // Nota: 'showIcon = true' asigna un valor por defecto si no se pasa la prop
  
  return (
    <div className={`alert alert-${type}`}>
      {/* Renderizado condicional del icono */}
      {showIcon && <span>üîî</span>}
      <p>{text}</p>
    </div>
  );
};
Ventajas de TS aqu√≠:

    IntelliSense: Al usar <Alert ... />, VS Code te sugerir√° text y type.
    Seguridad: Si escribes type="blue", TS te avisar√° del error porque "blue" no est√° en la lista de valores permitidos.

5. L√≥gica de Renderizado

En React no tenemos directivas como ng-if o v-for. Usamos JavaScript puro dentro de las llaves { }.
Renderizado Condicional (El "if")

Como no podemos poner un bloque if/else dentro del JSX (porque es una expresi√≥n), usamos:

    Operador Ternario (condicion ? true : false): Para elegir entre dos opciones.
    Operador l√≥gico AND (condicion && resultado): Para mostrar algo solo si la condici√≥n es verdadera.

// Ejemplo dentro del JSX
{isLoggedIn ? <LogoutButton /> : <LoginButton />}

{hasError && <p className="error">Ocurri√≥ un error</p>}
Renderizado de Listas (El "loop")

Usamos el m√©todo .map() de los arrays para transformar datos en elementos JSX.
Importante: Cada elemento de una lista debe tener una prop √∫nica llamada key. React la usa para identificar qu√© √≠tems han cambiado, se han agregado o eliminado, optimizando el rendimiento.
type ListProps = {
  items: string[]; // Array de strings
};

export const ShoppingList = ({ items }: ListProps) => {
  return (
    <ul>
      {items.map((item, index) => (
        // Usamos index como key solo si la lista es est√°tica
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
};
Resumen: Diferencias Clave
Concepto 	Vanilla JS / HTML 	React + TS
Bloques 	<div> repetidos 	<Componente /> reutilizable
Clases CSS 	class="box" 	className="box"
Datos din√°micos 	getElementById... 	{variable}
Par√°metros 	Argumentos sin validar 	Props tipadas (interface)
Bucles 	for / innerHTML 	items.map(...)
üõ†Ô∏è Preparaci√≥n para los Ejercicios

Para los ejercicios que haremos a continuaci√≥n, aseg√∫rate de que tu entorno cumple con los requisitos t√©cnicos:

    Node.js instalado.
    Visual Studio Code con la extensi√≥n ESLint y Prettier.
    Proyecto iniciado (usaremos Vite para esta sesi√≥n):
    npm create vite@latest mi-app-react -- --template react-ts


