Fundamentos de TypeScript para React

GuÃ­a de Supervivencia para Desarrolladores Vanilla JS.
Este documento resume los conceptos teÃ³ricos clave que trabajarÃ¡s en los ejercicios prÃ¡cticos. El objetivo no es aprenderse la documentaciÃ³n de TypeScript de memoria, sino entender las herramientas especÃ­ficas que necesitas para construir componentes en React de forma robusta.
1. Interfaces y Propiedades Opcionales

En Vanilla JS, pasamos objetos de un lado a otro sin estar seguros de quÃ© propiedades tienen. En React, los componentes reciben informaciÃ³n a travÃ©s de Props (que no es mÃ¡s que un objeto).
El Concepto: interface

Una interfaz es un "contrato". Define la forma exacta que debe tener un objeto. Si intentas acceder a una propiedad que no estÃ¡ en la interfaz, o le pasas un dato del tipo incorrecto, TypeScript te avisarÃ¡ antes de compilar.
El modificador ? (Opcional)

A veces, un dato no es obligatorio. AÃ±adiendo un signo de interrogaciÃ³n ? despuÃ©s del nombre de la propiedad, le decimos a TS que esa propiedad puede ser del tipo definido o undefined (puede no existir).
âš›ï¸ Â¿Por quÃ© lo necesitas para React?

Para definir las Props de tus componentes. Si un componente requiere un tÃ­tulo pero el subtÃ­tulo es extra, usarÃ¡s ?. Esto habilita el autocompletado en tu editor cuando uses el componente.

interface Usuario {
  nombre: string;
  email: string;
  telefono?: string; // Puede no tener telÃ©fono
}

2. Union Types y Literal Types

En Vanilla JS es comÃºn usar "Magic Strings": cadenas de texto que escribimos manualmente y que son propensas a errores. TypeScript soluciona esto restringiendo los valores posibles.
El Concepto: Union Types (|)

El operador pipe (|) funciona como un "O". Permite que una variable acepte mÃ¡s de un tipo de dato. Por ejemplo: type ID = string | number;
El Poder Real: Literal Types

AquÃ­ es donde ocurre la magia. En lugar de decir que una variable es string (que admite infinitas palabras), definimos una lista cerrada de valores exactos. Si intentas asignar algo fuera de esa lista, tu cÃ³digo marcarÃ¡ error.
âš›ï¸ Â¿Por quÃ© lo necesitas para React?

Para la GestiÃ³n de Estados (State). Evita usar mÃºltiples booleanos sueltos (isLoading, isError). AdemÃ¡s, al escribir el cÃ³digo, el editor te sugerirÃ¡ solo las opciones vÃ¡lidas.

type Alineacion = 'left' | 'center' | 'right';

type EstadoCarga = 'idle' | 'loading' | 'success' | 'error';

function mostrarAlerta(estado: EstadoCarga) {
   if (estado === 'error') { 
      // Solo entra si es exactamente 'error'
   }
}

3. Tipado de Funciones: Argumentos y Retornos

En JavaScript, las funciones son flexibles: reciben lo que sea y devuelven lo que sea. Esto es una fuente de bugs. En TypeScript, "candamos" la entrada y la salida.
Sintaxis BÃ¡sica

Debemos indicar el tipo de cada parÃ¡metro y, opcionalmente, el tipo de retorno despuÃ©s de los parÃ©ntesis.
(a: number, b: number): number
El tipo void

Muchas funciones en frontend no devuelven un cÃ¡lculo, sino que "hacen algo" (cambiar el DOM, lanzar una alerta, guardar en base de datos). Para indicar que una funciÃ³n no devuelve nada, usamos el tipo void.
âš›ï¸ Â¿Por quÃ© lo necesitas para React?

Esencial para los Event Handlers. Cuando pasas una funciÃ³n onClick a un componente hijo, debes definir en la interfaz del hijo quÃ© argumentos espera esa funciÃ³n y aclarar que devuelve void.

// 1. Tipado explÃ­cito de argumentos y retorno
const sumar = (a: number, b: number): number => {
  return a + b;
};

// 2. Void y Callbacks (Caso Real React)
interface PropsBoton {
  label: string;
  // "onClick" es una funciÃ³n que recibe un numero y no devuelve nada
  onClick: (id: number) => void; 
}

4. Arrays y Seguridad ante undefined

Definimos listas como Usuario[] o number[]. Lo importante aquÃ­ es usar mÃ©todos como .find(). En Vanilla JS asumes que encontrarÃ¡s el elemento. En TS, el mÃ©todo devuelve Elemento | undefined. TS te obligarÃ¡ a comprobar si el elemento existe antes de usarlo.
âš›ï¸ Â¿Por quÃ© lo necesitas para React?

Para renderizar listas con .map(). React es muy sensible a los errores; si intentas pintar usuario.nombre y usuario es undefined, la app explota (pantalla en blanco).
5. GenÃ©ricos (Generics)

Imagina <T> como una variable para tipos. En lugar de pasar un valor, pasas un tipo. Esto permite que la funciÃ³n capture el tipo de dato que le entra y lo use para definir su salida.
âš›ï¸ Â¿Por quÃ© lo necesitas para React?

Fundamentalmente para el hook useState. Cuando inicias un estado vacÃ­o, TS necesita saber quÃ© habrÃ¡ ahÃ­ en el futuro.

// Le decimos a useState que contendrÃ¡ un Usuario eventualmente
const [user, setUser] = useState<Usuario | null>(null);

6. El "Reducer" (Discriminated Unions)

Consiste en unir varias interfaces que tienen una propiedad comÃºn (generalmente llamada type o kind) con valores literales Ãºnicos. TS sabe que si compruebas esa propiedad, el resto del objeto tiene la forma correspondiente.
âš›ï¸ Â¿Por quÃ© lo necesitas para React?

Para useReducer. Es la forma estÃ¡ndar de manejar estados complejos donde una acciÃ³n tiene unos datos (payload) y otra tiene otros.

type Accion =
  | { tipo: 'LOGIN'; token: string } // Si es LOGIN, tiene token
  | { tipo: 'LOGOUT' };              // Si es LOGOUT, no tiene nada mÃ¡s

ğŸš€ Resumen para React
Concepto Vanilla JS 	Concepto TypeScript 	Uso en React
Objeto flexible 	Interface 	Definir Props
Variable multiusos 	Union Type (|) 	Estados (loading, error)
Callbacks dinÃ¡micos 	Function Types 	Eventos (onClick)
Array.find() 	Manejo de undefined 	Listas y selecciÃ³n
Funciones universales 	GenÃ©ricos <T> 	useState<T>, Hooks
Switch/Case lÃ³gico 	Discriminated Unions 	useReducer, Redux
