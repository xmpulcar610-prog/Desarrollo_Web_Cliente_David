7. Métodos Funcionales de Arrays
Métodos Funcionales de Arrays

En el ecosistema de JavaScript moderno (ES6+) y, particularmente, en el desarrollo de interfaces con librerías como React, el paradigma de la programación funcional ha cobrado una relevancia capital. A diferencia del enfoque imperativo clásico, donde nos centramos en cómo realizar una tarea paso a paso (usando bucles for o while), el enfoque funcional y declarativo nos permite describir qué queremos conseguir.

El dominio de los métodos map, filter y find no es opcional; es un requisito estructural para entender cómo React gestiona las listas, renderiza componentes dinámicos y actualiza el estado de manera inmutable.
Nota Teórica: Inmutabilidad
Un principio clave en React es la inmutabilidad. Los métodos que estudiaremos a continuación (especialmente map y filter) son preferibles a operaciones como push o splice porque no modifican el array original, sino que devuelven una nueva instancia del array con las transformaciones aplicadas. Esto permite a React detectar cambios en el estado y renderizar la interfaz de manera eficiente.
1. Array.prototype.map(): Transformación de Datos

El método map() es, posiblemente, la herramienta más utilizada en React. Su función es iterar sobre cada elemento de un array, aplicar una función de transformación (callback) a dicho elemento y devolver un nuevo array con los resultados. La longitud del array resultante siempre será idéntica a la del array original.

Matemáticamente, si tenemos un conjunto $A$ y una función $f$, map produce un conjunto $B$ donde cada elemento $b_i = f(a_i)$.
Ejemplo Práctico: Transformación de Objetos a JSX (Simulado)

En este ejemplo, transformamos un array de datos "crudos" en una estructura de cadenas que simularía HTML o componentes React.

// Array de objetos original (base de datos simulada)
const usuarios = [
  { id: 1, nombre: "Ana García", rol: "Admin" },
  { id: 2, nombre: "Carlos Ruiz", rol: "Editor" },
  { id: 3, nombre: "Lucía Perez", rol: "Lector" }
];

// Uso de MAP para transformar datos en elementos visuales
const tarjetasUsuario = usuarios.map((usuario) => {
  // Retornamos un string template (simulando JSX)
  return `<div class="card">
            <h3>${usuario.nombre}</h3>
            <p>Rol: ${usuario.rol}</p>
          </div>`;
});

console.log(tarjetasUsuario);
/* Salida:
[
  '<div class="card"><h3>Ana García</h3>...</div>',
  '<div class="card"><h3>Carlos Ruiz</h3>...</div>',
  ...
] 
*/

2. Array.prototype.filter(): Subconjuntos y Eliminación

El método filter() crea un nuevo array con todos los elementos que cumplan una condición implementada por la función dada. Es decir, actúa como un tamiz. Si la función callback devuelve true, el elemento se conserva; si devuelve false, se descarta.

En React, este método es el estándar para operaciones de "borrado". Dado que no debemos eliminar elementos del estado directamente (mutación), lo que hacemos es crear un nuevo estado que contiene todos los elementos excepto el que queremos borrar.
Ejemplo Práctico: Eliminación Inmutable

Supongamos que queremos eliminar al usuario con ID 2. Usaremos filter para quedarnos con todos los que no tengan ese ID.

const tareas = [
  { id: 101, texto: "Aprender React", completada: true },
  { id: 102, texto: "Estudiar Hooks", completada: false },
  { id: 103, texto: "Entender Redux", completada: false }
];

const idParaEliminar = 102;

// Lógica: "Quédate con las tareas cuyo ID sea DISTINTO al que quiero borrar"
const tareasRestantes = tareas.filter(tarea => tarea.id !== idParaEliminar);

console.log(tareasRestantes);
/* Salida:
[
  { id: 101, texto: "Aprender React", completada: true },
  { id: 103, texto: "Entender Redux", completada: false }
]
// El objeto con id 102 ha sido excluido del nuevo array.
*/

3. Array.prototype.find(): Búsqueda Unitaria

A diferencia de filter, que siempre devuelve un array (aunque sea vacío o de un solo elemento), el método find() devuelve el valor del primer elemento del array que cumple la función de prueba proporcionada. Si ningún elemento cumple la condición, devuelve undefined.

Es extremadamente eficiente para encontrar un registro específico por un identificador único, ya que detiene la iteración tan pronto como encuentra la coincidencia.
Ejemplo Práctico: Localizar un recurso

const inventario = [
  { sku: "A-001", producto: "Teclado", stock: 5 },
  { sku: "B-002", producto: "Ratón", stock: 0 },
  { sku: "C-003", producto: "Monitor", stock: 2 }
];

// Buscar el producto con SKU "B-002"
const productoEncontrado = inventario.find(item => item.sku === "B-002");

if (productoEncontrado) {
    console.log(`Producto: ${productoEncontrado.producto}`); 
    // Salida: "Producto: Ratón"
}

// Intento de buscar algo inexistente
const inexistente = inventario.find(item => item.sku === "Z-999");
console.log(inexistente); 
// Salida: undefined

4. Composición: Encadenamiento de Métodos (Chaining)

Una de las características más potentes de estos métodos funcionales es que, dado que map y filter devuelven arrays, pueden encadenarse (chaining) para realizar operaciones complejas de manera muy legible y secuencial.
Importante: El orden importa. Filtrar primero y mapear después suele ser más eficiente computacionalmente, ya que map iterará sobre un conjunto reducido de elementos.

const transacciones = [
  { cantidad: 100, moneda: "USD", tipo: "deposito" },
  { cantidad: -50, moneda: "USD", tipo: "retiro" },
  { cantidad: 200, moneda: "EUR", tipo: "deposito" }, // Distinta moneda
  { cantidad: 300, moneda: "USD", tipo: "deposito" }
];

// Objetivo: Obtener solo las cantidades de los depósitos en USD
const cantidadesUSD = transacciones
  .filter(tx => tx.moneda === "USD" && tx.tipo === "deposito") // Paso 1: Filtrar
  .map(tx => tx.cantidad);                                   // Paso 2: Transformar

console.log(cantidadesUSD);
// Salida: [100, 300]


