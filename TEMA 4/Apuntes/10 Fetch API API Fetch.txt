10. Fetch API
API Fetch

En el desarrollo de aplicaciones modernas con React, la gestión eficiente de datos remotos es una competencia fundamental. Antes de la estandarización de ES6, la comunicación asíncrona dependía en gran medida del objeto XMLHttpRequest, el cual, aunque funcional, presentaba una sintaxis verbosa y una gestión compleja del flujo de eventos ("callback hell").

La Fetch API surge como el estándar moderno para realizar peticiones HTTP asíncronas en el navegador. Proporciona una interfaz JavaScript más potente y flexible para acceder y manipular el canal HTTP y sus recursos. A diferencia de su predecesor, Fetch está construido íntegramente sobre el concepto de Promesas (Promises), lo que facilita enormemente la escritura de código asíncrono limpio, legible y mantenible, especialmente cuando se combina con la sintaxis async/await.
Nota Importante para Desarrolladores React: Aunque existen librerías externas populares como Axios, dominar la API nativa Fetch es esencial. React no incluye una capa de datos propia ("opinionated data fetching"), por lo que comprender cómo funciona Fetch nativamente le permitirá implementar Custom Hooks y gestionar el estado asíncrono sin dependencias adicionales innecesarias.
1. Anatomía Básica y el Flujo de Promesas

La función global fetch() inicia el proceso de obtención de un recurso de la red. Esta función devuelve una promesa que se resuelve con un objeto Response. Es crucial entender que este objeto no contiene directamente los datos en formato JSON, sino que representa la respuesta HTTP completa (cabeceras, estado, etc.).

Para extraer el cuerpo de la respuesta (el "payload"), debemos utilizar métodos asíncronos adicionales proporcionados por el objeto Response, siendo .json() el más común en aplicaciones React.
Ejemplo: Petición GET Básica

A continuación, observamos una implementación canónica utilizando async/await, que es el estándar de facto en el desarrollo moderno:

const obtenerUsuarios = async () => {
try {
    // 1. Iniciamos la petición. Por defecto es GET.
    const response = await fetch("[https://jsonplaceholder.typicode.com/users](https://jsonplaceholder.typicode.com/users)");

    // 2. Extraemos el JSON del cuerpo de la respuesta (también es una Promesa)
    const data = await response.json();

    console.log("Datos recibidos:", data);
    return data;

} catch (error) {
    // Captura errores de red (ej: DNS, pérdida de conexión)
    console.error("Error en la petición:", error);
}
};

2. Configuración de Peticiones: POST, PUT, DELETE

Por defecto, fetch realiza una petición GET. Para realizar operaciones de escritura o actualización (POST, PUT, PATCH, DELETE), debemos pasar un segundo argumento opcional: un objeto de configuración (init object).

Este objeto permite definir:

    method: El verbo HTTP (POST, PUT, etc.).
    headers: Metadatos de la petición. Es crítico establecer 'Content-Type': 'application/json' cuando enviamos datos JSON, para que el servidor sepa cómo interpretar el cuerpo.
    body: Los datos a enviar. Dado que HTTP es un protocolo de texto, debemos serializar nuestros objetos JavaScript a cadenas de texto usando JSON.stringify().

const crearNuevoUsuario = async (nuevoUsuario) => {
const url = "[https://api.ejemplo.com/v1/usuarios](https://api.ejemplo.com/v1/usuarios)";

const config = {
    method: "POST", // Verbo HTTP
    headers: {
        "Content-Type": "application/json", // Indicamos formato JSON
        "Authorization": "Bearer token_seguridad_123"
    },
    // Serialización del objeto JS a string JSON
    body: JSON.stringify(nuevoUsuario)
};

try {
    const response = await fetch(url, config);
    const result = await response.json();
    console.log("Usuario creado:", result);
} catch (error) {
    console.error("Fallo al crear usuario", error);
}
};

3. Gestión Rigurosa de Errores

Uno de los aspectos más técnicos y frecuentemente malinterpretados de la Fetch API es su comportamiento ante errores HTTP.
Diferencia Crítica: Una promesa devuelta por fetch() NO será rechazada (no entrará en el catch) si el servidor responde con un código de estado de error HTTP (como 404 Not Found o 500 Internal Server Error). La promesa solo se rechaza ante fallos de red (DNS, timeout, sin conexión).

Para gestionar errores HTTP (4xx o 5xx), debemos verificar manualmente la propiedad response.ok. Esta propiedad es un booleano que devuelve true si el código de estado está en el rango 200-299.

const obtenerDatosSeguros = async (id) => {
try {
    const response = await fetch(`https://api.ejemplo.com/items/${id}`);

    // Verificación explícita del estado HTTP
    if (!response.ok) {
        // Lanzamos un error manualmente para enviarlo al bloque catch
        // Incluimos el status para depuración (ej: 404)
        throw new Error(`Error HTTP: ${response.status} - ${response.statusText}`);
    }

    const data = await response.json();
    return data;

} catch (error) {
    // Aquí llegarán tanto errores de red como los errores HTTP lanzados arriba
    console.error("Gestión centralizada de errores:", error.message);
}
};

4. Fetch en el Contexto de React: AbortController

En React, las peticiones suelen hacerse dentro del hook useEffect. Un problema común ocurre cuando un componente inicia una petición pero se desmonta (el usuario cambia de página) antes de que la petición termine. Intentar actualizar el estado de un componente desmontado genera una advertencia de "memory leak".

Para solucionar esto de manera profesional, utilizamos AbortController, una interfaz web estándar que permite cancelar peticiones asíncronas.

import { useEffect, useState } from 'react';
const ComponenteUsuario = ({ userId }) => { const [usuario, setUsuario] = useState(null);

useEffect(() => {
    // 1. Instanciamos el controlador de aborto
    const controller = new AbortController();
    const signal = controller.signal;

    const fetchData = async () => {
        try {
            // 2. Conectamos la señal a la petición fetch
            const res = await fetch(`https://api.xyz/users/${userId}`, { signal });
            
            if (!res.ok) throw new Error('Error de carga');
            
            const data = await res.json();
            setUsuario(data);

        } catch (err) {
            // 3. Filtramos el error si fue causado por el aborto
            if (err.name === 'AbortError') {
                console.log('Petición cancelada limpiamente');
            } else {
                console.error('Error real:', err);
            }
        }
    };

    fetchData();

    // 4. Función de limpieza (cleanup) del useEffect
    return () => {
        controller.abort();
    };

}, [userId]); // Se ejecuta si cambia el userId

if (!usuario) return "Cargando...";
return `Usuario: ${usuario.name}`;
};

Resumen y Buenas Prácticas

Para integrar Fetch profesionalmente en sus proyectos:

    Utilice siempre async/await para mantener la legibilidad, evitando cadenas infinitas de .then().
    Recuerde que Fetch no lanza errores en 404/500; implemente siempre la comprobación if (!response.ok).
    Configure las cabeceras correctamente, especialmente Content-Type: application/json en peticiones POST/PUT.
    En componentes React, utilice AbortController para evitar fugas de memoria y errores de estado en componentes desmontados.


