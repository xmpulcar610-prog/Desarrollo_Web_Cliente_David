9. Asincronía en JavaScript: Promesas y Async/Await
Asincronía en JavaScript: Promesas y Async/Await

En el desarrollo de aplicaciones modernas con React, la gestión de la asincronía es una competencia fundamental. JavaScript es un lenguaje single-threaded (de un solo hilo), lo que significa que solo puede ejecutar una tarea a la vez en el hilo principal. Si operaciones costosas como las peticiones de red a una API (Fetch), lectura de archivos o temporizadores se ejecutaran de manera síncrona, bloquearían el renderizado de la interfaz de usuario, resultando en una experiencia de usuario deficiente ("congelamiento" de la pantalla).

Para solucionar esto, JavaScript utiliza el Event Loop y patrones asíncronos. En este artículo, profundizaremos en la evolución moderna de estos patrones: las Promesas (ES6) y la sintaxis Async/Await (ES8).
Nota Conceptual: Antes de ES6, la asincronía se manejaba principalmente mediante callbacks. El uso anidado excesivo de callbacks conducía al conocido "Callback Hell", dificultando la legibilidad y el manejo de errores. Las Promesas surgieron para aplanar este flujo y proporcionar una interfaz más estandarizada.
1. El Objeto Promise (ES6)

Una Promesa es un objeto que representa la terminación o el fracaso eventual de una operación asíncrona y su valor resultante. Esencialmente, es un "recibo" que JavaScript nos entrega prometiendo que, en el futuro, nos dará un dato o nos notificará un error.

Una Promesa se encuentra siempre en uno de estos tres estados:

    Pending (Pendiente): Estado inicial, ni cumplida ni rechazada.
    Fulfilled (Cumplida): La operación se completó con éxito (se llama a resolve).
    Rejected (Rechazada): La operación falló (se llama a reject).

Anatomía de una Promesa

Para crear una promesa manualmente (aunque en React generalmente consumimos promesas ya creadas por librerías como fetch o axios), utilizamos el constructor new Promise.

// Simulación de una petición a base de datos
const consultarBaseDeDatos = () => {
    return new Promise((resolve, reject) => {
        const exito = true; // Simulamos si la operación fue bien o mal

        setTimeout(() => {
            if (exito) {
                // Si todo va bien, resolvemos la promesa con los datos
                resolve({ id: 1, usuario: "Ana Ruiz" });
            } else {
                // Si falla, rechazamos la promesa con un error
                reject("Error 500: No se pudo conectar a la BD");
            }
        }, 2000); // Simulamos un retardo de 2 segundos
    });
};

Consumo de Promesas: .then(), .catch() y .finally()

Una vez que tenemos una función que retorna una promesa, debemos "consumirla" para reaccionar a su cambio de estado. No podemos acceder al valor directamente de forma síncrona.

console.log("Iniciando petición...");

consultarBaseDeDatos()
    .then((datos) => {
        // Se ejecuta solo si la promesa es resuelta (resolve)
        console.log("Datos recibidos:", datos);
        // Podemos retornar un valor para el siguiente .then si encadenamos
        return datos.usuario;
    })
    .then((nombre) => {
        // Encadenamiento de promesas
        console.log("Procesando usuario:", nombre.toUpperCase());
    })
    .catch((error) => {
        // Se ejecuta si ocurre un error en cualquier punto de la cadena
        console.error("Hubo un fallo:", error);
    })
    .finally(() => {
        // Se ejecuta siempre, haya éxito o error (útil para ocultar spinners de carga)
        console.log("Operación finalizada.");
    });

2. Async / Await (ES8/ES2017)

Aunque las promesas mejoraron los callbacks, el encadenamiento excesivo de .then() puede volverse verboso y difícil de leer. ECMAScript 2017 introdujo Async/Await, que es "syntactic sugar" (azúcar sintáctico) sobre las Promesas.

Esta sintaxis nos permite escribir código asíncrono que se lee y comporta como si fuera síncrono, facilitando enormemente la lógica de control.

    async: Se coloca antes de la declaración de una función. Asegura que la función devuelva siempre una Promesa.
    await: Solo puede usarse dentro de una función async. Pausa la ejecución de la función hasta que la promesa se resuelva o rechace.

Refactorización a Async/Await

Veamos el mismo ejemplo anterior, reescrito con esta sintaxis moderna. Observen cómo el flujo de lectura es vertical y natural.

const ejecutarProceso = async () => {
    try {
        console.log("Iniciando petición...");
        
        // La ejecución se PAUSA aquí hasta que consultarBaseDeDatos resuelva
        // No hay callbacks, el valor resuelto se asigna a 'datos'
        const datos = await consultarBaseDeDatos();
        
        console.log("Datos recibidos:", datos);
        
        // Lógica síncrona posterior
        const nombreMayus = datos.usuario.toUpperCase();
        console.log("Procesando usuario:", nombreMayus);
        
    } catch (error) {
        // Si la promesa es rechazada (reject), el flujo salta al bloque catch
        console.error("Capturamos el error:", error);
    } finally {
        console.log("Operación finalizada.");
    }
};

// Ejecutamos la función asíncrona
ejecutarProceso();

Importante para React: En componentes funcionales de React, solemos usar useEffect para la carga de datos. Como la función pasada a useEffect no puede ser asíncrona directamente (debe retornar undefined o una función de limpieza), es un patrón común declarar una función async interna y ejecutarla inmediatamente.
Ejemplo aplicado: Fetch API con Async/Await

Este es el patrón estándar de la industria que encontrarán frecuentemente al conectar React con APIs externas.

const obtenerUsuarios = async () => {
    try {
        // 1. Petición HTTP
        const respuesta = await fetch('https://jsonplaceholder.typicode.com/users');
        
        // 2. Verificación de estado HTTP
        if (!respuesta.ok) {
            throw new Error(`Error HTTP: ${respuesta.status}`);
        }

        // 3. Extracción del JSON (también es una promesa)
        const usuarios = await respuesta.json();
        
        return usuarios;

    } catch (error) {
        console.error("Fallo en la red:", error.message);
    }
};

3. Manejo de Promesas en Paralelo

A menudo en React necesitamos cargar datos de múltiples fuentes antes de renderizar la vista. Si usamos await secuencialmente, creamos un efecto de "cascada" (waterfall) que ralentiza la aplicación. Para solucionar esto, utilizamos Promise.all.

const cargarTablero = async () => {
    try {
        // Iniciamos ambas promesas simultáneamente, sin await individual aún
        const promesaUsuarios = fetch('/api/usuarios');
        const promesaPosts = fetch('/api/posts');

        // Promise.all espera a que TODAS se resuelvan
        // Si una falla, todo el Promise.all falla inmediatamente
        const [resUsuarios, resPosts] = await Promise.all([
            promesaUsuarios, 
            promesaPosts
        ]);

        const usuarios = await resUsuarios.json();
        const posts = await resPosts.json();

        console.log("Todo cargado en paralelo");

    } catch (error) {
        console.error("Error en la carga inicial", error);
    }
};

Resumen

    JavaScript es asíncrono y no bloqueante gracias al Event Loop.
    Las Promesas son objetos que representan un valor futuro (éxito o error).
    Async/Await es la forma moderna y legible de consumir promesas, permitiendo usar bloques try/catch tradicionales.
    En React, el dominio de estos conceptos es crucial para realizar peticiones HTTP (API Calls) de manera eficiente y controlar los estados de carga y error en la interfaz.


