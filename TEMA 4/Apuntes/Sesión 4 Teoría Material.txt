Sesi贸n 4: Teor铆a
 Material Docente: Sesi贸n 4
Formularios y Reutilizaci贸n de L贸gica (Custom Hooks)
1. Formularios en React: Componentes Controlados

En HTML tradicional, los elementos de formulario mantienen su propio estado interno. En React, preferimos que el Estado (useState) sea la "煤nica fuente de la verdad".
El patr贸n "Controlled Component"

Para controlar un input, debemos hacer dos cosas:

    Vincular el valor: Asignar la prop value al estado.
    Escuchar cambios: Usar onChange para actualizar el estado.

import { useState } from 'react';

const SimpleForm = () => {
  const [email, setEmail] = useState('');

  return (
    <form>
      <label>Email:</label>
      <input
        type="email"
        value={email} // 1. React controla lo que se ve
        onChange={(e) => setEmail(e.target.value)} // 2. React actualiza
      />
      <p>Est谩s escribiendo: {email}</p>
    </form>
  );
};
2. Gesti贸n de Formularios M煤ltiples

Tener un useState separado para cada campo se vuelve inmanejable. La soluci贸n profesional es usar un 煤nico estado de objeto.

Usamos el atributo name del input y la sintaxis de Computed Property Names ([name]: value) para actualizar din谩micamente.
const [formData, setFormData] = useState({
  username: '',
  password: '',
  country: 'Spain'
});

const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  const { name, value } = e.target;
  
  setFormData({
    ...formData, // Copiamos lo anterior
    [name]: value // Actualizamos solo el campo modificado
  });
};
3. Componentes No Controlados (Uncontrolled)

A veces, no necesitamos validar cada pulsaci贸n (ej: subida de archivos o integraci贸n con librer铆as ajenas a React). En estos casos, usamos una Referencia (useRef) para leer el valor solo al enviar.
const UncontrolledForm = () => {
  const nameRef = useRef<HTMLInputElement>(null);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    alert(`Nombre enviado: ${nameRef.current?.value}`);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input ref={nameRef} type="text" defaultValue="Anon" />
      <button type="submit">Enviar</button>
    </form>
  );
};
4. Custom Hooks: Tu propia l贸gica reutilizable

React nos permite crear nuestros propios hooks para extraer l贸gica de negocio de la interfaz. Un Custom Hook es una funci贸n que empieza por use y llama a otros hooks.
Ejemplo: useCounter
Imagina que necesitamos contadores en varios sitios (carrito, likes, galer铆a). En lugar de reescribir la l贸gica, la encapsulamos.

Archivo: src/hooks/useCounter.ts
import { useState } from 'react';

export const useCounter = (initialValue = 0) => {
  const [count, setCount] = useState(initialValue);

  const increment = () => setCount(c => c + 1);
  const decrement = () => setCount(c => c - 1);
  const reset = () => setCount(initialValue);

  // Devolvemos lo que el componente necesita
  return { count, increment, decrement, reset };
};

Uso en el Componente:
const Product = () => {
  // 隆L贸gica en una sola l铆nea!
  const { count, increment, decrement } = useCounter(1);

  return (
    <div>
      <button onClick={decrement}>-</button>
      <span>{count}</span>
      <button onClick={increment}>+</button>
    </div>
  );
};
Resumen de la Sesi贸n
Concepto 	Descripci贸n 	Clave
Controlled 	El estado de React maneja el input. 	value={state} + onChange
Uncontrolled 	El DOM maneja el input. 	ref={inputRef}
Custom Hook 	Funci贸n use... reutilizable. 	Separa L贸gica vs Vista.
